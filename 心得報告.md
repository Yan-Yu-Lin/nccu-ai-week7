# Week 7 作業心得 - GPT-5 API 程式設計助手

**林晏宇 | 111360128 | 北科大電子四甲**

---

## 相關連結

- [Google Colab Notebook](https://colab.research.google.com/drive/1ZBgj11XP3c09N7mDfGvfMVxVyrTs8Cfc?usp=sharing)
- [GitHub Repository](https://github.com/Yan-Yu-Lin/nccu-ai-week7)
- [Claude Code 協作紀錄](https://wombats-relax-qft.craft.me/lp79kiwP0LnCbf)
- 資料來源：
  - [GPT-5 官方文件](https://platform.openai.com/docs/guides/latest-model)
  - [Function Calling 指南](https://platform.openai.com/docs/guides/function-calling)
  - [Text Generation 指南](https://platform.openai.com/docs/guides/text)

---

## 為什麼要做這個 Chatbot？

在開發 AI 應用的過程中，我經常遇到一個很實際的問題：當我請 AI 助手（像是 Claude 或 ChatGPT）幫我寫跟 OpenAI API 相關的程式時，它們常常會用過時的 API 寫法。比如說現在 GPT-5 已經推薦使用 Responses API，但 AI 助手可能還在用舊的 Chat Completions API 的寫法，或是參數名稱、結構都不對，導致程式直接報錯。

這個問題的根本原因是：AI 模型的訓練資料有截止日期，它們不知道最新的 API 變更。OpenAI 的 API 更新速度又很快，從 GPT-4 到 GPT-5，從 Chat Completions 到 Responses API，很多寫法都改了。

所以我想：如果能做一個 chatbot，讓它可以即時查閱最新的官方文件，那不就能解決這個問題了嗎？這就是 RAG（檢索增強生成）最經典的應用場景 - 需要準確、最新、可追溯來源的技術資訊。

---

## 技術特色

### 智能分塊策略

在建立向量資料庫時，我沒有用傳統的「固定字數切分」或「按照標題切分」，而是用了 GPT-5 的 custom tool calling 來做語義分塊。

具體做法是：
1. 定義一個 `save_chunk` custom tool
2. 給 GPT-5 整份文件，請它按照語義邏輯切分
3. GPT-5 會遞迴呼叫 `save_chunk` 工具，每次儲存一個語義完整的 chunk
4. 透過 tool calling loop 持續處理，直到整份文件處理完畢

這種方法的好處是：
- **語義完整**：每個 chunk 都是一個完整的概念單元（完整的段落、Q&A 對、程式碼範例等）
- **保持原文**：不改寫、不總結，完全保留原文內容
- **智慧判斷**：由 GPT-5 判斷最佳的切分點，比固定規則更靈活

最終將 GPT-5 官方文件切分成 56 個語義完整的 chunks，每個都能獨立理解，也能準確回答特定技術問題。

### 智慧檢索機制

這個 chatbot 最特別的地方是：它不是每次都搜尋文件（那樣會很浪費 token），而是由 GPT-5 自己判斷什麼時候需要查資料。

具體來說，我給 GPT-5 提供了一個叫 `search_chunks` 的工具（function tool），當使用者問的問題需要技術細節時，GPT-5 會主動呼叫這個工具去搜尋向量資料庫。如果只是一般對話或是 GPT-5 本身就知道答案的問題，它就不會呼叫工具，直接回答。

這種「按需檢索」的設計比傳統的「每次都檢索」更有效率，也展示了 tool calling 在實際應用中的價值。

### 向量資料庫

我把 GPT-5 的官方文件切成 56 個文件片段（chunks），用 OpenAI 的 `text-embedding-3-large` 模型產生 embeddings，然後存到 FAISS 向量資料庫裡。當需要搜尋時，會找出語義上最相關的前 5 個片段給 GPT-5 參考。

涵蓋的主題包括：
- Function calling 和 custom tools 的使用
- Reasoning effort 控制（minimal, low, medium, high）
- Text verbosity 設定
- Tool calling 最佳實踐
- Context-free grammars（CFG）

---

## Prompt 設計

```python
SYSTEM_PROMPT = """你是一位專業的 GPT-5 Response API 程式設計助手。

你的專長領域:
- GPT-5 Response API 的使用方式
- Function calling 和 custom tools
- Reasoning effort 控制 (minimal, low, medium, high)
- Text verbosity 設定
- Tool calling 的最佳實踐

回答風格:
- 友善、專業、有耐心
- 提供清楚的程式碼範例
- 解釋技術概念時用簡單易懂的方式
- 如果不確定答案,誠實告知並建議查閱官方文件
- 所有程式碼範例或任何與程式碼相關的內容都必須放在 code block 中,否則不易閱讀

重要: 當你需要查詢 GPT-5 API 相關資料時,請使用 search_chunks 工具搜尋文件內容。"""
```

這個 prompt 設計的重點：

1. **明確的角色定位**：告訴 GPT-5 它是專業的 API 助手，不是通用聊天機器人
2. **專長領域列表**：讓使用者知道可以問什麼，也幫助 GPT-5 判斷要不要使用工具
3. **強調誠實性**：如果不確定答案，要明確告知，而不是編造資訊
4. **格式要求**：程式碼必須放在 code block 裡，這是技術文件很重要的一點
5. **工具使用指示**：明確告訴 GPT-5 何時該呼叫 search_chunks

---

## 對話實際範例

### 範例 1：查詢 Custom Tools 用法

[圖片待補]

這個例子展示了當使用者詢問技術問題時，GPT-5 會主動呼叫 `search_chunks` 工具搜尋文件，然後基於檢索到的內容回答問題。

### 範例 2：Reasoning Effort 差異解釋

[圖片待補]

展示 GPT-5 如何解釋不同 reasoning effort 設定的差異，並提供實際的使用建議。

### 範例 3：程式碼範例生成

[圖片待補]

展示 GPT-5 如何根據文件內容提供完整的程式碼範例，並正確放在 code block 中。

---

## 心得與反思

### 遇到的挑戰

開發過程中遇到最大的問題是 API key 的設定。一開始在 Colab 環境中，雖然用 `userdata.get('OPENAI_API_KEY')` 取得了 API key，但沒有設定成環境變數，導致 OpenAI client 初始化時找不到 key。後來在 `setup_environment()` 函數中加上 `os.environ['OPENAI_API_KEY'] = api_key` 就解決了。

這個 bug 讓我更理解 Python 環境變數的運作方式，以及為什麼有些函數會預設從環境變數讀取設定。

### Tool Calling Loop 的理解

實作 tool calling loop 時，我參考了官方文件的流程：

1. 呼叫 GPT-5 並提供可用的工具
2. 檢查 response.output 中是否有 function_call
3. 執行對應的函數並產生 function_call_output
4. 把所有內容加回 input_messages
5. 再次呼叫 GPT-5，讓它基於檢索結果回答

一開始不太確定要怎麼處理 response.output 中的各種 item（reasoning、function_call、message 等），後來理解到要把整個 output 都加回 input 才能保留完整的對話脈絡。

### RAG 在實際開發中的價值

透過這次作業，我深刻體會到 RAG 不只是一個學術概念，而是能解決真實問題的技術。特別是在技術文件這種「需要準確、最新、可追溯」的場景，RAG 比純粹依賴模型記憶要可靠得多。

而且透過 tool calling 實現的「智慧檢索」，比起傳統的「永遠檢索」或「永不檢索」更有彈性，讓系統能根據實際需求動態調整行為。

### 未來改進方向

1. **擴充文件來源**：目前只涵蓋 GPT-5 API，未來可以加入更多 OpenAI 產品的文件（如 Whisper、DALL-E 等）
2. **支援多語言**：現在只有英文文件，可以考慮加入中文翻譯或雙語對照
3. **優化 chunking 策略**：目前的切分方式可能還不夠好，可以研究更智慧的文件切分方法
4. **加入引用來源**：回答時標註資訊來自文件的哪個部分，提高可信度

---

## 結語

這個作業讓我從實務角度理解了 RAG 的價值，也學會如何結合 tool calling 來實現更彈性的檢索機制。更重要的是，我做出了一個真正能解決自己開發痛點的工具 - 一個能提供最新 API 資訊的程式設計助手。

這種「為了解決實際問題而學習技術」的過程，比起單純完成作業要有意義得多。
