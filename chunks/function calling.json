[
  {
    "chunk_id": "call_Xia0qrl5zipobCNEAc0jvsSc",
    "text": "Function calling\n================\n\nGive models access to new functionality and data they can use to follow instructions and respond to prompts.\n\n**Function calling** (also known as **tool calling**) provides a powerful and flexible way for OpenAI models to interface with external systems and access data outside their training data. This guide shows how you can connect a model to data and actions provided by your application. We'll show how to use function tools (defined by a JSON schema) and custom tools which work with free form text inputs and outputs.",
    "source_file": "function calling.md",
    "chunk_index": 0,
    "char_count": 560
  },
  {
    "chunk_id": "call_o4Rjfm8bjbhI6HdjTv6OumPP",
    "text": "How it works\n------------\n\nLet's begin by understanding a few key terms about tool calling. After we have a shared vocabulary for tool calling, we'll show you how it's done with some practical examples.\n\nTools - functionality we give the model\n\nA **function** or **tool** refers in the abstract to a piece of functionality that we tell the model it has access to. As a model generates a response to a prompt, it may decide that it needs data or functionality provided by a tool to follow the prompt's instructions.\n\nYou could give the model access to tools that:\n\n*   Get today's weather for a location\n*   Access account details for a given user ID\n*   Issue refunds for a lost order\n\nOr anything else you'd like the model to be able to know or do as it responds to a prompt.\n\nWhen we make an API request to the model with a prompt, we can include a list of tools the model could consider using. For example, if we wanted the model to be able to answer questions about the current weather somewhere in the world, we might give it access to a `get_weather` tool that takes `location` as an argument.\n\nTool calls - requests from the model to use tools\n\nA **function call** or **tool call** refers to a special kind of response we can get from the model if it examines a prompt, and then determines that in order to follow the instructions in the prompt, it needs to call one of the tools we made available to it.\n\nIf the model receives a prompt like \"what is the weather in Paris?\" in an API request, it could respond to that prompt with a tool call for the `get_weather` tool, with `Paris` as the `location` argument.\n\nTool call outputs - output we generate for the model\n\nA **function call output** or **tool call output** refers to the response a tool generates using the input from a model's tool call. The tool call output can either be structured JSON or plain text, and it should contain a reference to a specific model tool call (referenced by `call_id` in the examples to come). To complete our weather example:\n\n*   The model has access to a `get_weather` **tool** that takes `location` as an argument.\n*   In response to a prompt like \"what's the weather in Paris?\" the model returns a **tool call** that contains a `location` argument with a value of `Paris`\n*   The **tool call output** might return a JSON object (e.g., `{\"temperature\": \"25\", \"unit\": \"C\"}`, indicating a current temperature of 25 degrees), [Image contents](/docs/guides/images), or [File contents](/docs/guides/pdf-files).\n\nWe then send all of the tool definition, the original prompt, the model's tool call, and the tool call output back to the model to finally receive a text response like:\n\n```text\nThe weather in Paris today is 25C.\n```",
    "source_file": "function calling.md",
    "chunk_index": 1,
    "char_count": 2720
  },
  {
    "chunk_id": "call_xqb6ZTsDBWaIAC0iEqAI3Hb8",
    "text": "Functions versus tools\n\n*   A function is a specific kind of tool, defined by a JSON schema. A function definition allows the model to pass data to your application, where your code can access data or take actions suggested by the model.\n*   In addition to function tools, there are custom tools (described in this guide) that work with free text inputs and outputs.\n*   There are also [built-in tools](/docs/guides/tools) that are part of the OpenAI platform. These tools enable the model to [search the web](/docs/guides/tools-web-search), [execute code](/docs/guides/tools-code-interpreter), access the functionality of an [MCP server](/docs/guides/tools-remote-mcp), and more.\n\n### The tool calling flow\n\nTool calling is a multi-step conversation between your application and a model via the OpenAI API. The tool calling flow has five high level steps:\n\n1.  Make a request to the model with tools it could call\n2.  Receive a tool call from the model\n3.  Execute code on the application side with input from the tool call\n4.  Make a second request to the model with the tool output\n5.  Receive a final response from the model (or more tool calls)\n\n![Function Calling Diagram Steps](https://cdn.openai.com/API/docs/images/function-calling-diagram-steps.png)",
    "source_file": "function calling.md",
    "chunk_index": 2,
    "char_count": 1259
  },
  {
    "chunk_id": "call_qOEDIpoVOGXXlIgUSUvEQqQ1",
    "text": "Function tool example\n---------------------\n\nLet's look at an end-to-end tool calling flow for a `get_horoscope` function that gets a daily horoscope for an astrological sign.\n\nComplete tool calling example\n\n```python\nfrom openai import OpenAI\nimport json\n\nclient = OpenAI()\n\n# 1. Define a list of callable tools for the model\ntools = [\n    {\n        \"type\": \"function\",\n        \"name\": \"get_horoscope\",\n        \"description\": \"Get today's horoscope for an astrological sign.\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"sign\": {\n                    \"type\": \"string\",\n                    \"description\": \"An astrological sign like Taurus or Aquarius\",\n                },\n            },\n            \"required\": [\"sign\"],\n        },\n    },\n]\n\ndef get_horoscope(sign):\n    return f\"{sign}: Next Tuesday you will befriend a baby otter.\"\n\n# Create a running input list we will add to over time\ninput_list = [\n    {\"role\": \"user\", \"content\": \"What is my horoscope? I am an Aquarius.\"}\n]\n\n# 2. Prompt the model with tools defined\nresponse = client.responses.create(\n    model=\"gpt-5\",\n    tools=tools,\n    input=input_list,\n)\n\n# Save function call outputs for subsequent requests\ninput_list += response.output\n\nfor item in response.output:\n    if item.type == \"function_call\":\n        if item.name == \"get_horoscope\":\n            # 3. Execute the function logic for get_horoscope\n            horoscope = get_horoscope(json.loads(item.arguments))\n            \n            # 4. Provide function call results to the model\n            input_list.append({\n                \"type\": \"function_call_output\",\n                \"call_id\": item.call_id,\n                \"output\": json.dumps({\n                  \"horoscope\": horoscope\n                })\n            })\n\nprint(\"Final input:\")\nprint(input_list)\n\nresponse = client.responses.create(\n    model=\"gpt-5\",\n    instructions=\"Respond only with a horoscope generated by a tool.\",\n    tools=tools,\n    input=input_list,\n)\n\n# 5. The model should be able to give a response!\nprint(\"Final output:\")\nprint(response.model_dump_json(indent=2))\nprint(\"\\n\" + response.output_text)\n```\n\n\nNote that for reasoning models like GPT-5 or o4-mini, any reasoning items returned in model responses with tool calls must also be passed back with tool call outputs.",
    "source_file": "function calling.md",
    "chunk_index": 3,
    "char_count": 2334
  },
  {
    "chunk_id": "call_D562rX84m2fET1E0bW2EGPbq",
    "text": "Defining functions\n------------------\n\nFunctions can be set in the `tools` parameter of each API request. A function is defined by its schema, which informs the model what it does and what input arguments it expects. A function definition has the following properties:\n\n|Field|Description|\n|---|---|\n|type|This should always be function|\n|name|The function's name (e.g. get_weather)|\n|description|Details on when and how to use the function|\n|parameters|JSON schema defining the function's input arguments|\n|strict|Whether to enforce strict mode for the function call|\n\nHere is an example function definition for a `get_weather` function\n\n```json\n{\n    \"type\": \"function\",\n    \"name\": \"get_weather\",\n    \"description\": \"Retrieves current weather for the given location.\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"location\": {\n                \"type\": \"string\",\n                \"description\": \"City and country e.g. Bogotá, Colombia\"\n            },\n            \"units\": {\n                \"type\": \"string\",\n                \"enum\": [\"celsius\", \"fahrenheit\"],\n                \"description\": \"Units the temperature will be returned in.\"\n            }\n        },\n        \"required\": [\"location\", \"units\"],\n        \"additionalProperties\": false\n    },\n    \"strict\": true\n}\n```\n\nBecause the `parameters` are defined by a [JSON schema](https://json-schema.org/), you can leverage many of its rich features like property types, enums, descriptions, nested objects, and, recursive objects.",
    "source_file": "function calling.md",
    "chunk_index": 4,
    "char_count": 1519
  },
  {
    "chunk_id": "call_8aibAmam4YSnSHeN5RpaKop0",
    "text": "### Best practices for defining functions\n\n1.  **Write clear and detailed function names, parameter descriptions, and instructions.**\n    \n    *   **Explicitly describe the purpose of the function and each parameter** (and its format), and what the output represents.\n    *   **Use the system prompt to describe when (and when not) to use each function.** Generally, tell the model _exactly_ what to do.\n    *   **Include examples and edge cases**, especially to rectify any recurring failures. (**Note:** Adding examples may hurt performance for [reasoning models](/docs/guides/reasoning).)\n2.  **Apply software engineering best practices.**\n    \n    *   **Make the functions obvious and intuitive**. ([principle of least surprise](https://en.wikipedia.org/wiki/Principle_of_least_astonishment))\n    *   **Use enums** and object structure to make invalid states unrepresentable. (e.g. `toggle_light(on: bool, off: bool)` allows for invalid calls)\n    *   **Pass the intern test.** Can an intern/human correctly use the function given nothing but what you gave the model? (If not, what questions do they ask you? Add the answers to the prompt.)\n3.  **Offload the burden from the model and use code where possible.**\n    \n    *   **Don't make the model fill arguments you already know.** For example, if you already have an `order_id` based on a previous menu, don't have an `order_id` param – instead, have no params `submit_refund()` and pass the `order_id` with code.\n    *   **Combine functions that are always called in sequence.** For example, if you always call `mark_location()` after `query_location()`, just move the marking logic into the query function call.\n4.  **Keep the number of functions small for higher accuracy.**\n    \n    *   **Evaluate your performance** with different numbers of functions.\n    *   **Aim for fewer than 20 functions** at any one time, though this is just a soft suggestion.\n5.  **Leverage OpenAI resources.**\n    \n    *   **Generate and iterate on function schemas** in the [Playground](/playground).\n    *   **Consider [fine-tuning](https://platform.openai.com/docs/guides/fine-tuning) to increase function calling accuracy** for large numbers of functions or difficult tasks. ([cookbook](https://cookbook.openai.com/examples/fine_tuning_for_function_calling))",
    "source_file": "function calling.md",
    "chunk_index": 5,
    "char_count": 2301
  },
  {
    "chunk_id": "call_MBdTi8aPtCtOS3jtsEeOO9Xi",
    "text": "### Token Usage\n\nUnder the hood, functions are injected into the system message in a syntax the model has been trained on. This means functions count against the model's context limit and are billed as input tokens. If you run into token limits, we suggest limiting the number of functions or the length of the descriptions you provide for function parameters.\n\nIt is also possible to use [fine-tuning](/docs/guides/fine-tuning#fine-tuning-examples) to reduce the number of tokens used if you have many functions defined in your tools specification.",
    "source_file": "function calling.md",
    "chunk_index": 6,
    "char_count": 549
  },
  {
    "chunk_id": "call_CQOW43dtzFpthw7r1K6Yiyiw",
    "text": "Handling function calls\n-----------------------\n\nWhen the model calls a function, you must execute it and return the result. Since model responses can include zero, one, or multiple calls, it is best practice to assume there are several.\n\nThe response `output` array contains an entry with the `type` having a value of `function_call`. Each entry with a `call_id` (used later to submit the function result), `name`, and JSON-encoded `arguments`.\n\nSample response with multiple function calls\n\n```json\n[\n    {\n        \"id\": \"fc_12345xyz\",\n        \"call_id\": \"call_12345xyz\",\n        \"type\": \"function_call\",\n        \"name\": \"get_weather\",\n        \"arguments\": \"{\\\"location\\\":\\\"Paris, France\\\"}\"\n    },\n    {\n        \"id\": \"fc_67890abc\",\n        \"call_id\": \"call_67890abc\",\n        \"type\": \"function_call\",\n        \"name\": \"get_weather\",\n        \"arguments\": \"{\\\"location\\\":\\\"Bogotá, Colombia\\\"}\"\n    },\n    {\n        \"id\": \"fc_99999def\",\n        \"call_id\": \"call_99999def\",\n        \"type\": \"function_call\",\n        \"name\": \"send_email\",\n        \"arguments\": \"{\\\"to\\\":\\\"bob@email.com\\\",\\\"body\\\":\\\"Hi bob\\\"}\"\n    }\n]\n```\n\nExecute function calls and append results\n\n```python\nfor tool_call in response.output:\n    if tool_call.type != \"function_call\":\n        continue\n\n    name = tool_call.name\n    args = json.loads(tool_call.arguments)\n\n    result = call_function(name, args)\n    input_messages.append({\n        \"type\": \"function_call_output\",\n        \"call_id\": tool_call.call_id,\n        \"output\": str(result)\n    })\n```\n\n\nIn the example above, we have a hypothetical `call_function` to route each call. Here’s a possible implementation:\n\nExecute function calls and append results\n\n```python\ndef call_function(name, args):\n    if name == \"get_weather\":\n        return get_weather(**args)\n    if name == \"send_email\":\n        return send_email(**args)\n```\n\n\n### Formatting results\n\nA result must be a string, but the format is up to you (JSON, error codes, plain text, etc.). The model will interpret that string as needed.\n\nIf your function has no return value (e.g. `send_email`), simply return a string to indicate success or failure. (e.g. `\"success\"`)\n\n### Incorporating results into response\n\nAfter appending the results to your `input`, you can send them back to the model to get a final response.\n\nSend results back to model\n\n```python\nresponse = client.responses.create(\n    model=\"gpt-4.1\",\n    input=input_messages,\n    tools=tools,\n)\n```\n\n\nFinal response\n\n```json\n\"It's about 15°C in Paris, 18°C in Bogotá, and I've sent that email to Bob.\"\n```",
    "source_file": "function calling.md",
    "chunk_index": 7,
    "char_count": 2556
  },
  {
    "chunk_id": "call_OxFTXIsKWjGjZepi2rkmXLys",
    "text": "Additional configurations\n-------------------------\n\n### Tool choice\n\nBy default the model will determine when and how many tools to use. You can force specific behavior with the `tool_choice` parameter.\n\n1.  **Auto:** (_Default_) Call zero, one, or multiple functions. `tool_choice: \"auto\"`\n2.  **Required:** Call one or more functions. `tool_choice: \"required\"`\n3.  **Forced Function:** Call exactly one specific function. `tool_choice: {\"type\": \"function\", \"name\": \"get_weather\"}`\n4.  **Allowed tools:** Restrict the tool calls the model can make to a subset of the tools available to the model.\n\n**When to use allowed\\_tools**\n\nYou might want to configure an `allowed_tools` list in case you want to make only a subset of tools available across model requests, but not modify the list of tools you pass in, so you can maximize savings from [prompt caching](/docs/guides/prompt-caching).\n\n```json\n\"tool_choice\": {\n    \"type\": \"allowed_tools\",\n    \"mode\": \"auto\",\n    \"tools\": [\n        { \"type\": \"function\", \"name\": \"get_weather\" },\n        { \"type\": \"function\", \"name\": \"search_docs\" }\n    ]\n  }\n}\n```\n\nYou can also set `tool_choice` to `\"none\"` to imitate the behavior of passing no functions.\n\n### Parallel function calling\n\nParallel function calling is not possible when using [built-in tools](/docs/guides/tools).\n\nThe model may choose to call multiple functions in a single turn. You can prevent this by setting `parallel_tool_calls` to `false`, which ensures exactly zero or one tool is called.\n\n**Note:** Currently, if you are using a fine tuned model and the model calls multiple functions in one turn then [strict mode](/docs/guides/function-calling#strict-mode) will be disabled for those calls.\n\n**Note for `gpt-4.1-nano-2025-04-14`:** This snapshot of `gpt-4.1-nano` can sometimes include multiple tools calls for the same tool if parallel tool calls are enabled. It is recommended to disable this feature when using this nano snapshot.\n\n### Strict mode\n\nSetting `strict` to `true` will ensure function calls reliably adhere to the function schema, instead of being best effort. We recommend always enabling strict mode.\n\nUnder the hood, strict mode works by leveraging our [structured outputs](/docs/guides/structured-outputs) feature and therefore introduces a couple requirements:\n\n1.  `additionalProperties` must be set to `false` for each object in the `parameters`.\n2.  All fields in `properties` must be marked as `required`.\n\nYou can denote optional fields by adding `null` as a `type` option (see example below).\n\nStrict mode enabled\n\n```json\n{\n    \"type\": \"function\",\n    \"name\": \"get_weather\",\n    \"description\": \"Retrieves current weather for the given location.\",\n    \"strict\": true,\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"location\": {\n                \"type\": \"string\",\n                \"description\": \"City and country e.g. Bogotá, Colombia\"\n            },\n            \"units\": {\n                \"type\": [\"string\", \"null\"],\n                \"enum\": [\"celsius\", \"fahrenheit\"],\n                \"description\": \"Units the temperature will be returned in.\"\n            }\n        },\n        \"required\": [\"location\", \"units\"],\n        \"additionalProperties\": false\n    }\n}\n```\n\nStrict mode disabled\n\n```json\n{\n    \"type\": \"function\",\n    \"name\": \"get_weather\",\n    \"description\": \"Retrieves current weather for the given location.\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"location\": {\n                \"type\": \"string\",\n                \"description\": \"City and country e.g. Bogotá, Colombia\"\n            },\n            \"units\": {\n                \"type\": \"string\",\n                \"enum\": [\"celsius\", \"fahrenheit\"],\n                \"description\": \"Units the temperature will be returned in.\"\n            }\n        },\n        \"required\": [\"location\"],\n    }\n}\n```\n\nAll schemas generated in the [playground](/playground) have strict mode enabled.\n\nWhile we recommend you enable strict mode, it has a few limitations:\n\n1.  Some features of JSON schema are not supported. (See [supported schemas](/docs/guides/structured-outputs?context=with_parse#supported-schemas).)\n\nSpecifically for fine tuned models:\n\n1.  Schemas undergo additional processing on the first request (and are then cached). If your schemas vary from request to request, this may result in higher latencies.\n2.  Schemas are cached for performance, and are not eligible for [zero data retention](/docs/models#how-we-use-your-data).",
    "source_file": "function calling.md",
    "chunk_index": 8,
    "char_count": 4501
  },
  {
    "chunk_id": "call_9DTlOG7LoeFvGfQwP8bOg2Vu",
    "text": "Streaming\n---------\n\nStreaming can be used to surface progress by showing which function is called as the model fills its arguments, and even displaying the arguments in real time.\n\nStreaming function calls is very similar to streaming regular responses: you set `stream` to `true` and get different `event` objects.\n\nStreaming function calls\n\n```python\nfrom openai import OpenAI\n\nclient = OpenAI()\n\ntools = [{\n    \"type\": \"function\",\n    \"name\": \"get_weather\",\n    \"description\": \"Get current temperature for a given location.\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"location\": {\n                \"type\": \"string\",\n                \"description\": \"City and country e.g. Bogotá, Colombia\"\n            }\n        },\n        \"required\": [\n            \"location\"\n        ],\n        \"additionalProperties\": False\n    }\n}]\n\nstream = client.responses.create(\n    model=\"gpt-4.1\",\n    input=[{\"role\": \"user\", \"content\": \"What's the weather like in Paris today?\"}],\n    tools=tools,\n    stream=True\n)\n\nfor event in stream:\n    print(event)\n```\n\n\nOutput events\n\n```json\n{\"type\":\"response.output_item.added\",\"response_id\":\"resp_1234xyz\",\"output_index\":0,\"item\":{\"type\":\"function_call\",\"id\":\"fc_1234xyz\",\"call_id\":\"call_1234xyz\",\"name\":\"get_weather\",\"arguments\":\"\"}}\n{\"type\":\"response.function_call_arguments.delta\",\"response_id\":\"resp_1234xyz\",\"item_id\":\"fc_1234xyz\",\"output_index\":0,\"delta\":\"{\\\"\"}\n{\"type\":\"response.function_call_arguments.delta\",\"response_id\":\"resp_1234xyz\",\"item_id\":\"fc_1234xyz\",\"output_index\":0,\"delta\":\"location\"}\n{\"type\":\"response.function_call_arguments.delta\",\"response_id\":\"resp_1234xyz\",\"item_id\":\"fc_1234xyz\",\"output_index\":0,\"delta\":\"\\\":\\\"\"}\n{\"type\":\"response.function_call_arguments.delta\",\"response_id\":\"resp_1234xyz\",\"item_id\":\"fc_1234xyz\",\"output_index\":0,\"delta\":\"Paris\"}\n{\"type\":\"response.function_call_arguments.delta\",\"response_id\":\"resp_1234xyz\",\"item_id\":\"fc_1234xyz\",\"output_index\":0,\"delta\":\",\"}\n{\"type\":\"response.function_call_arguments.delta\",\"response_id\":\"resp_1234xyz\",\"item_id\":\"fc_1234xyz\",\"output_index\":0,\"delta\":\" France\"}\n{\"type\":\"response.function_call_arguments.delta\",\"response_id\":\"resp_1234xyz\",\"item_id\":\"fc_1234xyz\",\"output_index\":0,\"delta\":\"\\\"}\"}\n{\"type\":\"response.function_call_arguments.done\",\"response_id\":\"resp_1234xyz\",\"item_id\":\"fc_1234xyz\",\"output_index\":0,\"arguments\":\"{\\\"location\\\":\\\"Paris, France\\\"}\"}\n{\"type\":\"response.output_item.done\",\"response_id\":\"resp_1234xyz\",\"output_index\":0,\"item\":{\"type\":\"function_call\",\"id\":\"fc_1234xyz\",\"call_id\":\"call_1234xyz\",\"name\":\"get_weather\",\"arguments\":\"{\\\"location\\\":\\\"Paris, France\\\"}\"}}\n```\n\nInstead of aggregating chunks into a single `content` string, however, you're aggregating chunks into an encoded `arguments` JSON object.\n\nWhen the model calls one or more functions an event of type `response.output_item.added` will be emitted for each function call that contains the following fields:\n\n|Field|Description|\n|---|---|\n|response_id|The id of the response that the function call belongs to|\n|output_index|The index of the output item in the response. This represents the individual function calls in the response.|\n|item|The in-progress function call item that includes a name, arguments and id field|\n\nAfterwards you will receive a series of events of type `response.function_call_arguments.delta` which will contain the `delta` of the `arguments` field. These events contain the following fields:\n\n|Field|Description|\n|---|---|\n|response_id|The id of the response that the function call belongs to|\n|item_id|The id of the function call item that the delta belongs to|\n|output_index|The index of the output item in the response. This represents the individual function calls in the response.|\n|delta|The delta of the arguments field.|\n\nBelow is a code snippet demonstrating how to aggregate the `delta`s into a final `tool_call` object.\n\nAccumulating tool\\_call deltas\n\n```python\nfinal_tool_calls = {}\n\nfor event in stream:\n    if event.type === 'response.output_item.added':\n        final_tool_calls[event.output_index] = event.item;\n    elif event.type === 'response.function_call_arguments.delta':\n        index = event.output_index\n\n        if final_tool_calls[index]:\n            final_tool_calls[index].arguments += event.delta\n```\n\n\nAccumulated final\\_tool\\_calls\\[0\\]\n\n```json\n{\n    \"type\": \"function_call\",\n    \"id\": \"fc_1234xyz\",\n    \"call_id\": \"call_2345abc\",\n    \"name\": \"get_weather\",\n    \"arguments\": \"{\\\"location\\\":\\\"Paris, France\\\"}\"\n}\n```\n\nWhen the model has finished calling the functions an event of type `response.function_call_arguments.done` will be emitted. This event contains the entire function call including the following fields:\n\n|Field|Description|\n|---|---|\n|response_id|The id of the response that the function call belongs to|\n|output_index|The index of the output item in the response. This represents the individual function calls in the response.|\n|item|The function call item that includes a name, arguments and id field.|",
    "source_file": "function calling.md",
    "chunk_index": 9,
    "char_count": 5010
  },
  {
    "chunk_id": "call_sxkSGvjMBzW6CUCEaabaXvCq",
    "text": "Custom tools\n------------\n\nCustom tools work in much the same way as JSON schema-driven function tools. But rather than providing the model explicit instructions on what input your tool requires, the model can pass an arbitrary string back to your tool as input. This is useful to avoid unnecessarily wrapping a response in JSON, or to apply a custom grammar to the response (more on this below).\n\nThe following code sample shows creating a custom tool that expects to receive a string of text containing Python code as a response.\n\nCustom tool calling example\n\n```python\nfrom openai import OpenAI\n\nclient = OpenAI()\n\nresponse = client.responses.create(\n    model=\"gpt-5\",\n    input=\"Use the code_exec tool to print hello world to the console.\",\n    tools=[\n        {\n            \"type\": \"custom\",\n            \"name\": \"code_exec\",\n            \"description\": \"Executes arbitrary Python code.\",\n        }\n    ]\n)\nprint(response.output)\n```\n\n\nJust as before, the `output` array will contain a tool call generated by the model. Except this time, the tool call input is given as plain text.\n\n```json\n[\n    {\n        \"id\": \"rs_6890e972fa7c819ca8bc561526b989170694874912ae0ea6\",\n        \"type\": \"reasoning\",\n        \"content\": [],\n        \"summary\": []\n    },\n    {\n        \"id\": \"ctc_6890e975e86c819c9338825b3e1994810694874912ae0ea6\",\n        \"type\": \"custom_tool_call\",\n        \"status\": \"completed\",\n        \"call_id\": \"call_aGiFQkRWSWAIsMQ19fKqxUgb\",\n        \"input\": \"print(\\\"hello world\\\")\",\n        \"name\": \"code_exec\"\n    }\n]\n```",
    "source_file": "function calling.md",
    "chunk_index": 10,
    "char_count": 1530
  },
  {
    "chunk_id": "call_go2tnUCuFBDBWXgMZbSoVccA",
    "text": "Context-free grammars\n---------------------\n\nA [context-free grammar](https://en.wikipedia.org/wiki/Context-free_grammar) (CFG) is a set of rules that define how to produce valid text in a given format. For custom tools, you can provide a CFG that will constrain the model's text input for a custom tool.\n\nYou can provide a custom CFG using the `grammar` parameter when configuring a custom tool. Currently, we support two CFG syntaxes when defining grammars: `lark` and `regex`.",
    "source_file": "function calling.md",
    "chunk_index": 11,
    "char_count": 479
  },
  {
    "chunk_id": "call_eEibjYgCio8Hb1kbW3WmLy6y",
    "text": "Lark CFG\n--------\n\nLark context free grammar example\n\n```python\nfrom openai import OpenAI\n\nclient = OpenAI()\n\ngrammar = \"\"\"\nstart: expr\nexpr: term (SP ADD SP term)* -> add\n| term\nterm: factor (SP MUL SP factor)* -> mul\n| factor\nfactor: INT\nSP: \" \"\nADD: \"+\"\nMUL: \"*\"\n%import common.INT\n\"\"\"\n\nresponse = client.responses.create(\n    model=\"gpt-5\",\n    input=\"Use the math_exp tool to add four plus four.\",\n    tools=[\n        {\n            \"type\": \"custom\",\n            \"name\": \"math_exp\",\n            \"description\": \"Creates valid mathematical expressions\",\n            \"format\": {\n                \"type\": \"grammar\",\n                \"syntax\": \"lark\",\n                \"definition\": grammar,\n            },\n        }\n    ]\n)\nprint(response.output)\n```\n\n\nThe output from the tool should then conform to the Lark CFG that you defined:\n\n```json\n[\n    {\n        \"id\": \"rs_6890ed2b6374819dbbff5353e6664ef103f4db9848be4829\",\n        \"type\": \"reasoning\",\n        \"content\": [],\n        \"summary\": []\n    },\n    {\n        \"id\": \"ctc_6890ed2f32e8819daa62bef772b8c15503f4db9848be4829\",\n        \"type\": \"custom_tool_call\",\n        \"status\": \"completed\",\n        \"call_id\": \"call_pmlLjmvG33KJdyVdC4MVdk5N\",\n        \"input\": \"4 + 4\",\n        \"name\": \"math_exp\"\n    }\n]\n```\n\nGrammars are specified using a variation of [Lark](https://lark-parser.readthedocs.io/en/stable/index.html). Model sampling is constrained using [LLGuidance](https://github.com/guidance-ai/llguidance/blob/main/docs/syntax.md). Some features of Lark are not supported:\n\n*   Lookarounds in lexer regexes\n*   Lazy modifiers (`*?`, `+?`, `??`) in lexer regexes\n*   Priorities of terminals\n*   Templates\n*   Imports (other than built-in `%import` common)\n*   `%declare`s\n\nWe recommend using the [Lark IDE](https://www.lark-parser.org/ide/) to experiment with custom grammars.\n\n### Keep grammars simple\n\nTry to make your grammar as simple as possible. The OpenAI API may return an error if the grammar is too complex, so you should ensure that your desired grammar is compatible before using it in the API.\n\nLark grammars can be tricky to perfect. While simple grammars perform most reliably, complex grammars often require iteration on the grammar definition itself, the prompt, and the tool description to ensure that the model does not go out of distribution.\n\n### Correct versus incorrect patterns\n\nCorrect (single, bounded terminal):\n\n```text\nstart: SENTENCE\nSENTENCE: /[A-Za-z, ]*(the hero|a dragon|an old man|the princess)[A-Za-z, ]*(fought|saved|found|lost)[A-Za-z, ]*(a treasure|the kingdom|a secret|his way)[A-Za-z, ]*\\./\n```\n\nDo NOT do this (splitting across rules/terminals). This attempts to let rules partition free text between terminals. The lexer will greedily match the free-text pieces and you'll lose control:\n\n```text\nstart: sentence\nsentence: /[A-Za-z, ]+/ subject /[A-Za-z, ]+/ verb /[A-Za-z, ]+/ object /[A-Za-z, ]+/\n```\n\nLowercase rules don't influence how terminals are cut from the input—only terminal definitions do. When you need “free text between anchors,” make it one giant regex terminal so the lexer matches it exactly once with the structure you intend.\n\n### Terminals versus rules\n\nLark uses terminals for lexer tokens (by convention, `UPPERCASE`) and rules for parser productions (by convention, `lowercase`). The most practical way to stay within the supported subset and avoid surprises is to keep your grammar simple and explicit, and to use terminals and rules with a clear separation of concerns.\n\nThe regex syntax used by terminals is the [Rust regex crate syntax](https://docs.rs/regex/latest/regex/#syntax), not Python's `re` [module](https://docs.python.org/3/library/re.html).\n\n### Key ideas and best practices\n\n**Lexer runs before the parser**\n\nTerminals are matched by the lexer (greedily / longest match wins) before any CFG rule logic is applied. If you try to \"shape\" a terminal by splitting it across several rules, the lexer cannot be guided by those rules—only by terminal regexes.\n\n**Prefer one terminal when you're carving text out of freeform spans**\n\nIf you need to recognize a pattern embedded in arbitrary text (e.g., natural language with “anything” between anchors), express that as a single terminal. Do not try to interleave free‑text terminals with parser rules; the greedy lexer will not respect your intended boundaries and it is highly likely the model will go out of distribution.\n\n**Use rules to compose discrete tokens**\n\nRules are ideal when you're combining clearly delimited terminals (numbers, keywords, punctuation) into larger structures. They're not the right tool for constraining \"the stuff in between\" two terminals.\n\n**Keep terminals simple, bounded, and self-contained**\n\nFavor explicit character classes and bounded quantifiers (`{0,10}`, not unbounded `*` everywhere). If you need \"any text up to a period\", prefer something like `/[^.\\n]{0,10}*\\./` rather than `/.+\\./` to avoid runaway growth.\n\n**Use rules to combine tokens, not to steer regex internals**\n\nGood rule usage example:\n\n```text\nstart: expr\nNUMBER: /[0-9]+/\nPLUS: \"+\"\nMINUS: \"-\"\nexpr: term ((\"+\"|\"-\") term)*\nterm: NUMBER\n```\n\n**Treat whitespace explicitly**\n\nDon't rely on open-ended `%ignore` directives. Using unbounded ignore directives may cause the grammar to be too complex and/or may cause the model to go out of distribution. Prefer threading explicit terminals wherever whitespace is allowed.\n\n### Troubleshooting\n\n*   If the API rejects the grammar because it is too complex, simplify the rules and terminals and remove unbounded `%ignore`s.\n*   If custom tools are called with unexpected tokens, confirm terminals aren’t overlapping; check greedy lexer.\n*   When the model drifts \"out‑of‑distribution\" (shows up as the model producing excessively long or repetitive outputs, it is syntactically valid but is semantically wrong):\n    *   Tighten the grammar.\n    *   Iterate on the prompt (add few-shot examples) and tool description (explain the grammar and instruct the model to reason and conform to it).\n    *   Experiment with a higher reasoning effort (e.g, bump from medium to high).",
    "source_file": "function calling.md",
    "chunk_index": 12,
    "char_count": 6102
  },
  {
    "chunk_id": "call_yGIekxypqOF8d0Ph2hqRnfRP",
    "text": "Regex CFG\n---------\n\nRegex context free grammar example\n\n```python\nfrom openai import OpenAI\n\nclient = OpenAI()\n\ngrammar = r\"^(?P<month>January|February|March|April|May|June|July|August|September|October|November|December)\\s+(?P<day>\\d{1,2})(?:st|nd|rd|th)?\\s+(?P<year>\\d{4})\\s+at\\s+(?P<hour>0?[1-9]|1[0-2])(?P<ampm>AM|PM)$\"\n\nresponse = client.responses.create(\n    model=\"gpt-5\",\n    input=\"Use the timestamp tool to save a timestamp for August 7th 2025 at 10AM.\",\n    tools=[\n        {\n            \"type\": \"custom\",\n            \"name\": \"timestamp\",\n            \"description\": \"Saves a timestamp in date + time in 24-hr format.\",\n            \"format\": {\n                \"type\": \"grammar\",\n                \"syntax\": \"regex\",\n                \"definition\": grammar,\n            },\n        }\n    ]\n)\nprint(response.output)\n```\n\n\nThe output from the tool should then conform to the Regex CFG that you defined:\n\n```json\n[\n    {\n        \"id\": \"rs_6894f7a3dd4c81a1823a723a00bfa8710d7962f622d1c260\",\n        \"type\": \"reasoning\",\n        \"content\": [],\n        \"summary\": []\n    },\n    {\n        \"id\": \"ctc_6894f7ad7fb881a1bffa1f377393b1a40d7962f622d1c260\",\n        \"type\": \"custom_tool_call\",\n        \"status\": \"completed\",\n        \"call_id\": \"call_8m4XCnYvEmFlzHgDHbaOCFlK\",\n        \"input\": \"August 7th 2025 at 10AM\",\n        \"name\": \"timestamp\"\n    }\n]\n```\n\nAs with the Lark syntax, regexes use the [Rust regex crate syntax](https://docs.rs/regex/latest/regex/#syntax), not Python's `re` [module](https://docs.python.org/3/library/re.html).\n\nSome features of Regex are not supported:\n\n*   Lookarounds\n*   Lazy modifiers (`*?`, `+?`, `??`)\n\n### Key ideas and best practices\n\n**Pattern must be on one line**\n\nIf you need to match a newline in the input, use the escaped sequence `\\n`. Do not use verbose/extended mode, which allows patterns to span multiple lines.\n\n**Provide the regex as a plain pattern string**\n\nDon't enclose the pattern in `//`.\n\nWas this page useful?",
    "source_file": "function calling.md",
    "chunk_index": 13,
    "char_count": 1965
  }
]